// PIXI.js Engine

import * as PIXI from "pixi.js";
import "@pixi/unsafe-eval";

import { makeAutoObservable } from "mobx";
import { EngineEntity, RenderableEntity } from "./entity";
import { Store, RootStore, Reactive, Disposer } from "@renderer/store";

export type RenderFunction = (entity: Reactive<any>) => {
    disposers: Disposer[];
    baseDisplayObject: PIXI.DisplayObject;
};

export class EngineStore implements Store {
    rootStore: RootStore;
    ticker: PIXI.Ticker | undefined;
    stage: PIXI.Container | undefined;
    app: PIXI.Application | undefined;

    // @TODO: maybe entities don't need to be made observable anymore (they are stores)
    entities: { [key: string]: RenderableEntity } = {};

    disposers: { [key: string]: Disposer[] } = {};
    renderFunctions: { [key: string]: RenderFunction } = {};
    displayObjects: { [key: string]: PIXI.DisplayObject } = {};

    constructor(rootStore: RootStore) {
        makeAutoObservable(this, {
            disposers: false,
            renderFunctions: false,
            displayObjects: false,
            rootStore: false,
        });
        this.rootStore = rootStore;
    }

    start(parent: HTMLElement) {
        this.app = this.createApp(parent);
        this.stage = this.app.stage;
        this.ticker = this.app.ticker;
        // console.log(this.ticker.minFPS, this.ticker.maxFPS);

        this.ticker.add((delta) => {
            for (let entity of Object.values(this.entities)) {
                // console.log(this.ticker!.elapsedMS);
                entity._update(this.rootStore, this.ticker!.elapsedMS);
            }
        });
        // displayObject.zIndex = -1000;
        // Engine.stage.sortableChildren = true;
    }

    createApp(parent: HTMLElement) {
        const app = new PIXI.Application({
            background: "#000000",
            resizeTo: window,
        });
        parent.appendChild(app.view as HTMLCanvasElement);
        return app;
    }

    // @TODO: remove and rename addEntity to add
    // add(entity: EngineEntity) {
    //     this.entities[entity.id] = entity;
    //     // very important to pass the proxy generated by mobX, not ~entity~
    //     const disposers = this.renderEntity(this.entities[entity.id]);
    //     this.disposers[entity.id] = disposers;
    //     return this.entities[entity.id];
    // }

    add<T extends RenderableEntity>(entity: T): Reactive<T> {
        this.entities[entity.id] = entity;
        const result = entity._render(this.rootStore);
        const disposers = result.disposers;
        this.disposers[entity.id] = disposers;
        return this.entities[entity.id] as Reactive<T>; // return the proxy
    }

    // @TODO: I'm keeping this in case I need entities to always have access to the rootStore
    // addEntity<T extends RenderableEntity>(
    //     EntityClass: new (rootStore: RootStore, ...args: any[]) => T,
    //     ...args: any[]
    // ): Reactive<T> {
    //     const entity = new EntityClass(this.rootStore, ...args);
    //     this.entities[entity.id] = entity;
    //     this.disposers[entity.id] = entity.render();
    //     return this.entities[entity.id] as Reactive<T>; // return the proxy
    // }

    remove(entity: EngineEntity) {
        delete this.entities[entity.id];
        for (let disposer of this.disposers[entity.id]) {
            disposer();
        }
    }

    // private renderEntity(entity: EngineEntity): Disposer[] {
    //     return this.renderFunctions[entity.type](entity);
    // }

    getDisplayObject(entityId: string) {
        return this.displayObjects[entityId];
    }

    addDisplayObject(entityId: string, displayObject: PIXI.DisplayObject) {
        this.displayObjects[entityId] = displayObject;
        this.stage?.addChild(displayObject);
    }

    removeDisplayObject(entityId: string) {
        if (this.displayObjects[entityId]) {
            this.stage?.removeChild(this.displayObjects[entityId]);
        }
    }
}
