// PIXI.js Engine

import * as PIXI from "pixi.js";
import "@pixi/unsafe-eval";

import { makeAutoObservable } from "mobx";
import { EngineEntity, RenderableEntity } from "./entity";
import { FrameModule } from "./frame";
import { SpriteModule } from "./sprite";
import { Store, RootStore, Reactive, Disposer } from "@renderer/store";

export type RenderFunction = (entity: Reactive<any>) => Disposer[];

export class EngineStore implements Store {
    Frame!: FrameModule;
    Sprite!: SpriteModule;

    rootStore: RootStore;
    ticker: PIXI.Ticker | undefined;
    stage: PIXI.Container | undefined;
    app: PIXI.Application | undefined;
    entities: { [key: string]: RenderableEntity } = {};

    disposers: { [key: string]: Disposer[] } = {};
    renderFunctions: { [key: string]: RenderFunction } = {};
    displayObjects: { [key: string]: PIXI.DisplayObject } = {};

    constructor(rootStore: RootStore) {
        makeAutoObservable(this, {
            disposers: false,
            renderFunctions: false,
            displayObjects: false,
            rootStore: false,
            Frame: false,
            loadModules: false,
        });
        this.rootStore = rootStore;
    }

    loadModules() {
        this.Frame = new FrameModule(this.rootStore);
        this.Sprite = new SpriteModule(this.rootStore);
    }

    start(parent: HTMLElement) {
        this.app = this.createApp(parent);
        this.stage = this.app.stage;
        this.ticker = this.app.ticker;
        // displayObject.zIndex = -1000;
        // Engine.stage.sortableChildren = true;
    }

    createApp(parent: HTMLElement) {
        const app = new PIXI.Application({
            background: "#000000",
            resizeTo: window,
        });
        parent.appendChild(app.view as HTMLCanvasElement);
        return app;
    }

    // @TODO: remove and rename addEntity to add
    add(entity: EngineEntity) {
        this.entities[entity.id] = entity;
        // very important to pass the proxy generated by mobX, not ~entity~
        const disposers = this.renderEntity(this.entities[entity.id]);
        this.disposers[entity.id] = disposers;
        return this.entities[entity.id];
    }

    addEntity<T extends RenderableEntity>(entity: T): Reactive<T> {
        this.entities[entity.id] = entity;
        this.disposers[entity.id] = entity.render(this.rootStore);
        return this.entities[entity.id] as Reactive<T>; // return the proxy
    }

    // @TODO: I'm keeping this in case I need entities to always have access to the rootStore
    // addEntity<T extends RenderableEntity>(
    //     EntityClass: new (rootStore: RootStore, ...args: any[]) => T,
    //     ...args: any[]
    // ): Reactive<T> {
    //     const entity = new EntityClass(this.rootStore, ...args);
    //     this.entities[entity.id] = entity;
    //     this.disposers[entity.id] = entity.render();
    //     return this.entities[entity.id] as Reactive<T>; // return the proxy
    // }

    remove(entity: EngineEntity) {
        delete this.entities[entity.id];
        for (let disposer of this.disposers[entity.id]) {
            disposer();
        }
    }

    private renderEntity(entity: EngineEntity): Disposer[] {
        return this.renderFunctions[entity.type](entity);
    }

    getDisplayObject(entityId: string) {
        return this.displayObjects[entityId];
    }

    addDisplayObject(entityId: string, displayObject: PIXI.DisplayObject) {
        this.displayObjects[entityId] = displayObject;
        this.stage?.addChild(displayObject);
    }

    removeDisplayObject(entityId: string) {
        if (this.displayObjects[entityId]) {
            this.stage?.removeChild(this.displayObjects[entityId]);
        }
    }
}
